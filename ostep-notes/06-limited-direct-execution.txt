==> Time Sharing
  - run one process for a little while, then run another one, and so forth
  - achieves the illusion of parallelism (virtualization)

==> User Mode
  - code that runs in user mode in restricted in what it can 2025-05-25T14:08:05

==> Kernel Mode
  - code that runs in kernel mode has full access to the hardware and can execute any instruction

==> System call
  - allow the kernel to carefully expose certain key pieces of functionality to user programs, such as accessing the file system, creating processes, communicating with other processes, and allocating more memory

==> Flow of System Calls
  - user process calls a system call
  - system call program puts arguments in registers or on the stack
  - system call program puts system call number in a register
  - program executes a trap instruction (e.g., svc 0 on ARM, int 0x80 on x86)
  - CPU switches to kernel mode, and control is transferred to the kernel
  - kernel looks up the system call number in a table
  - kernel executes the system call
  - kernel returns to user mode
  - CPU switches back to user mode

==> Trap instruction
  - to execute a system call, a program must execute this special instruction
  - jumps into the kernel and raises the privilege level to kernel mode
  => Return-from-trap instruction
    - When finished running, the kernel calls this instruction
    - returns into the calling user program, while at the same time reducing the privilege level back to user mode

  - The CPU executes the instruction (system call instruction), the user-space program triggers it, and the OS kernel responds to it
  - ANALOGY: The syscall instruction as a doorbell: the user program rings it, the CPU hears it and routes control, and the kernel opens the door and handles the request

==> Random Notes
  - The putting of arguments in registers or on the stack is done by the user process not the CPU or OS.

==> Recap Notes
  - A trap is a system call or fault that causes the CPU to switch to kernel mode. When a system call trap is triggered (e.g., by the syscall instruction) the CPU saves the current program state (e.g., registers, flags, program counter) and switches to the kernel stack.
  - The kernel handles the syscall, and then uses a return-from-trap instruction (like sysret) to resume user-space execution.
The CPU executes that return instruction, restoring the saved state and returning control to the user program exactly where it left off.

LEFT OFF ON PAGE 4: VERY BAD IDEA
